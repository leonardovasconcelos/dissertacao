\chapter{Implementação}
\outlineon=0


\outline{
  Descrever o processo de Implementação no tinyos (libs, organização do código e TEPs).
  
}

Este capítulo trata sobre o sistema operacional TinyOS e da linguagem nesC. Aspectos importantes de sua arquitetura para a implementação de um protocolo de sincronização.



\section{Sistema Operacional}

\outline{
\begin{itemize}
 \item Gerencia de memória. Gerenciamento energético. Redes. Linguagem. Manipulação de interrupções. Programação baseada em eventos.
\end{itemize}    
}


%\cite{levis2004tinyos}
%\cite{gay2003nesc}
%We present nesC, a programming language for networked embedded systems that represent a new design space for application developers. An example of a networked embedded system is a sensor network, which consists of (potentially) thousands of tiny, low-power "motes," each of which execute concurrent, reactive programs that must operate with severe memory and power constraints.nesC's contribution is to support the special needs of this domain by exposing a programming model that incorporates event-driven execution, a flexible concurrency model, and component-oriented application design. Restrictions on the programming model allow the nesC compiler to perform whole-program analyses, including data-race detection (which improves reliability) and aggressive function inlining (which reduces resource consumption).nesC has been used to implement TinyOS, a small operating system for sensor networks, as well as several significant sensor applications. nesC and TinyOS have been adopted by a large number of sensor network research groups, and our experience and evaluation of the language shows that it is effective at supporting the complex, concurrent programming style demanded by this new class of deeply networked systems.


O desenvolvimento do FTSP+ foi realizado utilizando o sistema operacional TinyOS, que é um SO bem difundido na área de redes sensores sem fio \cite{levis2004tinyos}. O TinyOS não é um sistema operacional convencional, em que se instala completamente no sensor, ele se apresenta como um arcabouço de um conjunto de componentes reutilizáveis que permitem o desenvolvimento de aplicações para sistemas embarcados em conjunto com o SO. Esses componentes são separados por funções características, no momento de construir a aplicação somente os componentes especificados serão integrados na aplicação final, mantendo o uso minimal de recursos. 

Com a limitação de recursos nos dispositivos sensores o TinyOS conta com pouco menos de 400 \textit{bytes} de tamanho, é um sistema baseado em eventos, com suporte a concorrência, eventos assíncronos e comandos. Um programa em TinyOS possui a abstração dos componentes em um modelo de grafo, como vemos na Figura \ref{fig:diagrama_componentes}.


As aplicações e o próprio sistema operacional são escritos em nesC (\textit{networked systems C}) \cite{gay2003nesc} um dialeto da linguagem C, que dá o suporte a arquitetura de componentes e orientação a eventos, além de ser otimizada para reduzir o consumo de memória e ter primitivas que previnam problemas de baixo nível como condição de corrida. No desenvolvimento existe a separação da organização dos componentes e programação das interfaces, os componentes são conectados (\textit{wired}) juntos em um arquivo de aplicação, já o código dos eventos e tarefas são feitos em um arquivo de construção.


%Como o TinyOS tem o código aberto, é possível alterá-lo e criar ou estender suas funcionalidades.

Programas em nesC são construídos por itens definidos separadamente e então conectados de forma explicita para juntar todos em uma unidade \cite{levis2009tinyos}. A seguir definições importantes sobre essas características:

\begin{itemize}
 \item Componentes e interfaces: Um programa em nesC é um conjunto de componentes ligados entre si. O componente fornece interfaces que são responsáveis pela comunicação bidirecional entre os componentes, as interfaces fornecem comando e eventos.
 
 \item Implementação: A implementação pode ser dividida em duas partes no nesC, uma chamada \textit{modules} e outra \textit{configuration}. Em \textit{modules} é implementado as interfaces, já em \textit{configuration} é usado para juntar os componentes conectando suas interfaces.
 
 \item Modelo de concorrência: Define como os componentes interagem entre suas execuções. Temos dois tipos de tarefa, que são a tarefa (ou \textit{task}) propriamente dita e eventos de dispositivos. Quando uma tarefa é enviada para execução ela roda até completar, não fazendo preempção. Os eventos de dispositivos são como as tarefas, só que são geradas como respostas a eventos.
\end{itemize}







\section{Diagramas e Componentes}

\outline{
  O Tinyos tem o recurso de componentes para disponibilizar seus mais diversos recursos, descrever os componentes relevantes para o trabalho e os componentes resultantes das alterações.
}

O TinyOS foi desenvolvido seguindo um conjunto de diretrizes, chamado de TEP (TinyOS Enhancement Proposals) que orientam as modificações no núcleo do seu código, também é utilizado para guiar a criação de novas funcionalidades. Podemos citar as seguintes TEPs \cite{tinyos133, tinyos132, tinyos102} com definições importantes para a implementação do FTSP+:

\begin{itemize}
 \item TEP 102: Propõe a estrutura dos \texttt{Timers} (controladores do relógio) e suas propriedades de precisão, acurácia e tamanhos.
 \item TEP 132: Descreve o mecanismo de \textit{timestamp} no nível de acesso ao meio. A funcionalidade que fornece o tempo de envio e recebimento de uma mensagem no processo de comunicação.
 \item TEP 133: Descreve o funcionamento do mecanismo das mensagens de sincronização de tempo, como os tempos são convertidos do tempo do emissor para o do receptor e como são tratados nas pilhas de protocolos.
\end{itemize}

Os \textit{Timers} no TinyOS fornecem precisões listadas na Tabela \ref{tab:precision}, todas as precisões são binárias, ou seja, 1s contém 1024 milissegundos binários. A acurácia dependente de quão bem o dispositivo fornece de seu relógio, como vimos anteriormente os relógios são afetados pelas limitações de seu \textit{hardware}. Assim um relógio de um \textit{mote} que roda a 7.37MHz, tem valor real do relógio variando muito próximo desse valor. Os tamanhos são basicamente 8, 16, 32 e 64 \textit{bits}, sendo 32 \textit{bits} o tamanho indicado para representação dos tempos dos componentes.

\begin{table}[h]
\centering
\begin{tabular}{lccc}
Nome & TMilliC & T32kHz & TMicroC \\
\hline
Frequência & 1,024 Hz & 32,768 Hz & 0.9216 MHz \\
\hline
Precisão & 1024 ticks/s & 32768 ticks/s & 1048576 ticks/s \\
\hline
Periodo & 976 ms & 30.518 $\mu s$ & 1.084 $\mu s$
\end{tabular}
\caption{Precisões dos \textit{Timers} no TinyOS}
\label{tab:precision}
\end{table}%alemao


O FTSP+ foi elaborado utilizando os \textit{motes} Iris e Micaz \cite{Iris2007, Micaz}, e construído sobre a implementação já existente do FTSP. A Figura \ref{fig:diagrama_componentes} apresenta os componentes utilizados pelo FTSP+, a alteração descrita na Seção \ref{sec:mod} estão presentes no componente central da imagem o \texttt{TimeSyncP}.



\begin{figure}[h]
 \centering
 %\includegraphics[width=23cm, angle=90]{./figuras/time.png}
 \includegraphics{./figuras/time.eps}
 % tos.lib.ftsp.TimeSyncC.png: 1177x293 pixel, 72dpi, 41.52x10.34 cm, bb=0 0 1177 293
 \caption{Diagrama de Componentes do FTSP+}
 \label{fig:diagrama_componentes}
\end{figure}

O \texttt{TimeSyncP} faz parte a implementação original do FTSP, porém foi o único componente modificado. O FTSP usa uma mensagem de sincronização com informações como o nó raiz da rede, o nó que está enviando a mensagem de sincronização, o número de sequência da mensagem e o \textit{timestamp}. É acrescentado mais uma mensagem na comunicação, que é a mensagem de correção. A estrutura da mensagem é listada a seguir:

% \begin{figure}[h]
%  \begin{Verbatim}[numbersep=1pt,frame=single]
% typedef nx_struct TimeSyncMsg
% {
%  nx_uint16_t rootID;
%  nx_uint16_t nodeID; 
%  nx_uint8_t  seqNum;
%  nx_uint32_t globalTime;
%  nx_uint32_t localTime;
% } TimeSyncMsg;
% \end{Verbatim}
% \caption{Formato da mensagem de sincronização}
% \end{figure}

\begin{figure}[h]
 \begin{Verbatim}[numbersep=1pt,frame=single]
typedef nx_struct TimeSyncMsg
{
 nx_uint16_t rootID;
 nx_uint16_t nodeID;      
 nx_uint8_t  seqNum;
 nx_uint32_t correction; 
} TimeSyncMsg;
\end{Verbatim}
\caption{Formato da mensagem de sincronização}
\end{figure}


O mensagem conta com o \texttt{rootID}, se a mensagem tem \textit{root} com ID maior que a informação do \textit{root} local ela é descartada. O \texttt{nodeID} contém o ID de quem enviou a mensagem. O \texttt{seqNum} serve para identificar qual o \textit{timestamp} a mensagem está corrigindo. O campo \texttt{correction} é o campo que traz a estimativa de erro do emissor e é com ele que será feita a correção dos \textit{timestamp} anteriormente recebidos.

No documento da TEP 132 \cite{tinyos132}, é fornecido uma breve descrição sobre o padrão de \textit{timestamps} oferecidos pela interface \texttt{PacketTimeStamp} que faz o acesso ao tempo de recepção e envio de determinada mensagem.

A TEP 133 fornece a abstração para o mecanismo de sincronização de pares. Não provê um sincronização completa da redes, mas, com seus recursos é possível implementar um serviço de sincronização completo, exemplo o FTSP, pois os componentes e interfaces utilizados em sua implementação estão bem definidos em seu documento \cite{tinyos133}. 

Outro aspecto importante da TEP 133 é o seu guia de implementação, que compreende duas abordagens, uma em que é possível mudar o \textit{payload} da mensagem durante a transmissão usando a interrupção SFD dos rádios orientados a pacote. A segunda abordagem descreve a possibilidade da sincronização para plataformas em que não seja possível a alteração do conteúdo durante a transmissão. Podemos verificar que o FTSP atende a primeira abordagem, já a segunda não é atendida, porém com o FTSP+ ambas as abordagens são acolhidas.


O próximo capítulo traz experimento realizado com \textit{motes} reais, e gráficos estatísticos dos resultados encontrados. Os experimentos foram baseados nas técnicas desenvolvidas até aqui.