\section{\textit{Timestamp}}\label{sec:ftsp_timestamp}

\outline{
  Explicar como funciona a marcação de tempo no FTSP
}

%O \textit{timestamp} na camada de acesso ao meio é utilizado para reduzir o atraso gerado na etapa de comunicação do processo de sincronização.

O FTSP usa \textit{broadcast} para sincronizar seus nós, essa mensagem contém um \textit{timestamp} com o valor estimado do tempo global no momento em que a transmissão é realizada. No instante do recebimento os nó obtém o valor do tempo do seu relógio local, assim com a diferença entre o tempo global e o local o nó pode estimar o seu \textit{offset}. 

Caso a leitura do tempo seja armazenada na etapa de envio ainda no nível de aplicação, vários componentes de atrasos serão acumulados até que a mensagem seja lida pelos receptores, a Seção \ref{subsec:fontes_imp} lista esses componentes de atraso e a Tabela \ref{tab:decomp} quantifica a magnitude dessas fontes de imprecisão. Esse procedimento é ilustrado na Figura \ref{fig:comp_apptimestamp}. Note que no tempo $t_0$ é iniciado o processo de envio da mensagem de sincronização a partir do nó $i$, logo em seguida é criado o pacote que armazena o \textit{timestamp} $t_1$ e comanda o envio para o sistema operacional, que por sua vez, encaminha a mensagem para a pilha de protocolos. O tempo de acesso ao meio é variável e depende da janela de contenção da rede. Quando $i$ ganha o direito de enviar a mensagem, dá-se inicio a transmissão em $t_2$, em $t_3$ o nó $j$ termina de receber a transmissão, mas somente algum tempo depois o nó $j$ gera uma interrupção e o sistema operacional irá armazenar o \textit{timestamp} da recepção em $t_5$. Neste momento $j$ tem como calcular seu \textit{offset}, porém esse valor não é representativo devido aos atrasos que as marcas de tempo sofreram em relação de seus valores ideais.

%Para fazer isso o FTSP conta com o uso do \textit{timestamp} na camada MAC, que funciona da seguinte forma 




\begin{figure}[h]
 \centering
 \includegraphics{./figuras/comparacao_mactime.eps}
 % comparacao_mactime.eps: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Procedimento de leitura do \textit{timestamp} em nível de aplicação}
 \label{fig:comp_apptimestamp}
\end{figure}




Visando corrigir esse problema, a leitura dos tempos pode ser efetuada em locais mais estratégicos. Vários transmissores tem \textit{chips} capazes de modificar o conteúdo da mensagem depois da transmissão ter sido iniciada, \textit{timestamps} na camada de acesso ao meio podem ser facilmente implementados nesses dispositivos para eliminar vários componentes de atraso.




\begin{figure}[h]
 \centering
 \includegraphics{./figuras/comparacao_mactime2.eps}
 % comparacao_mactime2.eps: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Procedimento de leitura do \textit{timestamp} na camada MAC}
 \label{fig:comp_mactimestamp}
\end{figure}




Desta forma, quando é iniciado o processo de transmissão a mensagem vai para a fila de saída, porém, quando os primeiros \textit{bits} são enviados o \textit{timestamp} é executado. Em um espaço reservado no \textit{payload} do pacote é inserido uma informação adicional de quanto tempo a mensagem levou desde a criação até o envio, procedimento este realizado pelo \textit{chip} de rádio (uma interrupção SFD - \textit{Start Frame Delimiter}). Isso permite que o receptor calcule e elimine os atrasos relacionados ao envio. Do lado do receptor é possível usar MAC \textit{timestamp} no momento do recebimento e também eliminar os atrasos do receptor.

Na Figura \ref{fig:comp_mactimestamp} têm-se a ilustração do procedimento de envio de mensagem de sincronização utilizando \textit{timestamp} na camada MAC. O funcionamento do MAC \textit{timestamp} segue basicamente esse diagrama, onde o nó $i$ inicia o procedimento de envio mensagem de sincronização em $t_0$, logo em seguida cria-se a mensagem e comanda-se o envio. No início da transmissão é inserido na mensagem o tempo $t_3$, que é o mesmo instante do início do envio dos dados. Já no lado do receptor, depois do atraso de propagação e do tempo de transmissão o último \textit{bit} chega, então uma interrupção é disparada no tempo $t_5$ junto com ela é registrada o \textit{timestamp} $t_5$.




O formato da mensagem do FTSP segue o modelo da Figura \ref{fig:pacote}. A mensagem começa com um preâmbulo, seguido do conjunto de \textit{bytes} de SYNC, um campo de dados e por fim um campo de identificação de erros CRC. O PREAMBLULO é usado para sincronizar a frequência dos rádios, o SYNC é utilizado para calcular o \textit{bit offset} e com isso alinhar os \textit{bytes} no receptor. Os \textit{timestamps} são armazenados no limite de cada \textit{byte} transmitido depois de SYNC, tando no envio quanto no recebimento. Os tempos são normalizados subtraindo um múltiplo inteiro correspondente ao tempo de transmissão. Somente o tempo final é inserido no campo de dados da mensagem.

\begin{figure}[H]
 \centering
 \includegraphics{./figuras/ftsp_packet.eps}
 % ftsp_packet.eps: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=0 0 221 17
 \caption{Formato da mensagem do FTSP}
 \label{fig:pacote}
\end{figure}






A forma como o \textit{timestamp} é realizado depende do modelo do \textit{chip} de rádio. Pode ser dividido em dois tipos, orientado a \textit{byte} ou orientado pacotes. Nos \textit{chips} orientados a \textit{byte} como o CC1000 \cite{cc1000} (Mica2 e Mica2dot), geram interrupção por cada \textit{byte} transmitido, essa interrupção armazena no metadado da mensagem o \textit{timestamp} do momento em que o \textit{byte} foi transmitido ou recebido. Ao final da transmissão é possível determinar um \textit{timestamp} único, calculando a taxa de transmissão e a média dos \textit{timestamps}. Os \textit{chips} CC2420 \cite{chipcon20032} (MicaZ, TelosA, TelosB, TmoteSky) e RF230 (Iris) \cite{iris2006crossbow} são orientados a pacote, nesses rádios ao invés de marcarem os tempos em cada \textit{byte} transmitido, fazem apenas uma marcação para o pacote inteiro usando apenas uma única interrupção SFD.









% Texto da tep 133:
% Several transceivers allow for modifying the contents of a packet after packet transmission is started. Packet-level time synchronization can be implemented very efficiently on such platforms.
% 
% Transmitter's story
% 
% When the communications stack services a TimeSyncAMSend.send command called with event timestamp t\_e, it stores t\_e (e.g. in a map with the pointer of the message\_t as key) and sets the designated timestamp field in the packet payload to 0x80000000.
% When the packet starts being transmitted over the communication medium, a corresponding hardware event is timestamped (e.g. an SFD interrupt). Let us denote this transmission timestamp with t\_tx. The difference of event timestamp t\_e and transmit timestamp t\_tx is written into the designated timestamp field in the payload of the packet (typically into the footer, since the first few bytes might have been transmitted by this time). That is, the information the packet contains at the instance when being sent over the communications medium is the age of the event (i.e. how much time ago the event had occurred).
% If an error occurs with timestamping the transmission or with writing the package payload after transmission has started, then the designated timestamp field in the packet payload will contain 0x80000000, indicating the error to the receiver.
% Receiver's story
% 
% The packet is timestamped with the receiver node's local clock at reception (e.g. with the timestamp of the SFD interrupt). Let us denote the time of reception with t\_rx. The reception timestamp is stored in the metadata structure of the message\_t [5].
% When the event time is queried via the TimeSyncPacket interface, the eventTime command returns the sum of the value stored in the designated timestamp field in packet payload and the reception timestamp, i.e. e\_t- e\_tx+e\_rx. This value corresponds to the time of the event in the receiver's local clock.
% The TimeSyncPacket.isValid command returns FALSE if the time value stored in the payload equals 0x80000000 or if the communications stack failed to timestamp the reception of the packet. Otherwise TRUE is returned, which indicates that the value returned by TimeSyncPacket.eventTime can be trusted.
